<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Audio Volume Booster with Download</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin-top: 30px;
        }
        input, button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 10px;
        }
        audio {
            margin-top: 20px;
            width: 80%;
        }
    </style>
</head>
<body>
    <h1>Audio Volume Booster with Download</h1>
    <input type="file" id="fileInput" accept="audio/*,video/*" />
    <br/>
    <label for="gainValue">Volume Level: </label>
    <input type="number" id="gainValue" value="1" step="0.1" min="0" />
    <br/>
    <button onclick="playAndDownload()">Play & Download</button>
    <br/>
    <audio id="audioPlayer" controls></audio>
    <br/>
    <a id="downloadLink" style="display: none;">Download Amplified Audio</a>

    <script>
        async function playAndDownload() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) {
                alert("Please select an audio or video file.");
                return;
            }

            const gainValue = parseFloat(document.getElementById('gainValue').value);

            const arrayBuffer = await file.arrayBuffer();
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

            // Create buffer source and gain node
            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffer;
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = gainValue;

            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            // Play the audio
            const blobUrl = URL.createObjectURL(file);
            const audioPlayer = document.getElementById('audioPlayer');
            audioPlayer.src = blobUrl;
            audioPlayer.play();

            // Create amplified buffer
            const numberOfChannels = audioBuffer.numberOfChannels;
            const length = audioBuffer.length;
            const sampleRate = audioBuffer.sampleRate;

            const newBuffer = audioCtx.createBuffer(numberOfChannels, length, sampleRate);

            for (let channel = 0; channel < numberOfChannels; channel++) {
                const inputData = audioBuffer.getChannelData(channel);
                const outputData = newBuffer.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    outputData[i] = inputData[i] * gainValue;
                    // Clipping prevention
                    if (outputData[i] > 1) outputData[i] = 1;
                    if (outputData[i] < -1) outputData[i] = -1;
                }
            }

            // Convert to WAV and offer download
            const wavBlob = bufferToWav(newBuffer);
            const downloadLink = document.getElementById('downloadLink');
            downloadLink.href = URL.createObjectURL(wavBlob);
            downloadLink.download = "amplified_audio.wav";
            downloadLink.style.display = "inline-block";
            downloadLink.textContent = "Download Amplified Audio";
        }

        // WAV encoder
        function bufferToWav(buffer) {
            const numOfChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            let result;
            let offset = 0;
            let length = buffer.length * numOfChannels * 2 + 44;

            result = new ArrayBuffer(length);
            let view = new DataView(result);

            // RIFF identifier
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, length - 8, true); offset += 4;
            writeString(view, offset, 'WAVE'); offset += 4;
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4;
            view.setUint16(offset, format, true); offset += 2;
            view.setUint16(offset, numOfChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, sampleRate * numOfChannels * 2, true); offset += 4;
            view.setUint16(offset, numOfChannels * 2, true); offset += 2;
            view.setUint16(offset, bitDepth, true); offset += 2;
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, length - offset - 4, true); offset += 4;

            // Write PCM samples
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numOfChannels; channel++) {
                    let sample = buffer.getChannelData(channel)[i];
                    sample = Math.max(-1, Math.min(1, sample));
                    sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, sample, true);
                    offset += 2;
                }
            }
            return new Blob([result], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
                                                                          </html>
